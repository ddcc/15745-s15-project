\documentclass[letterpaper,11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage[hyphens]{url}
\usepackage{colortbl}
\usepackage{listings}
\begin{document}

\date{\today}

\title{\Large \bf Memory Safety Bug Hunting with BAP} 

\author{Tiffany Bao, Dominic Chen, Rijnard van Tonder}

\maketitle

\section{Introduction}
\label{intro}

\paragraph{The Problem}

\paragraph{}
Although numerous debugging tools have been developed for performing static and
dynamic software analysis, the majority of these require access to source
code or utilization of special compile足time flags to embed debug information
within the output binary. In contrast, little effort has been spent on
developing static binary analysis tools which can directly analyze
off足the足shelf executables without executing them. For this project, we plan to
focus on a subset of common programming bugs that tend to introduce security
vulnerabilities, known as memory足safety errors. Examples of these include
buffer overflows, double frees, and uninitialized variables. In particular, we
define \emph{Security Outcomes} with respect to certain memory-safety errors,
and subsequently implement and test static analyses that yield these outcomes.
All analyses were written against our group's Binary Analysis Platform
(BAP) \cite{bap, brumley2011bap}.

\paragraph{}
A factor of this research area that appeals to many is the ability to
conclude whether vulnerabilities do or do not exist by performing
an analysis purely on the binary level. Due to the inherent difficulties
of operating at this level, %we can expand on what these difficulties are...
our approach to the problem starts out coarse, and continues to be
incrementally refined as we become more familiar with the numerous
barriers that inhibit vulnerability detection in binaries. In this respect,
we have much to say towards lessons learned in \S\ref{lessonslearned}.

\subsection{Approach Overview}
\label{approachoverview}

\paragraph{}
At the outset of this project, we planned to implement and test the static
analyses with respect to our original proposal:

\begin{enumerate}
  \item Intraprocedural data dependency resolution of instructions
  \item Intraprocedural detection of unchecked memory allocations
  \item Basic intraprocedural detection of buffer overflows in the stack
  \item Basic intraprocedural detection of buffer overflows in the heap
\end{enumerate}

\paragraph{}
Equipped with the knowledge of data flow dependency between instructions (1),
we determined to reason about various properties of typical vulnerabilities
that we could check (2-4). For example, we might like to follow how arguments
to a `strcpy` call are influenced by previous instructions as a function of
the stack register.

\subsection{Related Work}

\paragraph{}
Engler et. al. found numerous bugs with system-specific static analyses,
implemented by way of a meta-compilation language for the \texttt{gcc} compiler
\cite{dawson, dawson2}. Analyses are composed in the form of correctness rules
and automatic inference of rules form source code. Memory errors that are
checked include null pointer bugs, not checking allocation results, and uses of
freed pointers. This relates to our goal in that we would ideally like to perform
similar checks, albeit at the level of complexity of binary code. Whereas
Engler's work matured into a generic platform for specifying analyses, we must
start first with an ad-hoc approach to gain insight and familiarity in the
problem domain presented by binaries.

% needs more

\subsection{Contributions}

Our key technical contributions are as follows:

\begin{enumerate}
  \item A dataflow analysis framework for BAP.
  \item General plugins for BAP that deliver
    \begin{enumerate}
      \item reaching definitions and
      \item data flow dependency resolution (use-def and def-use chains).
      \item registers corresponding to function call arguments and returns,
            according to the ARM ABI.
    \end{enumerate}
  \item Security-specific plugins for BAP that produce security outcomes by checking
    \begin{enumerate}
      \item whether memory allocation checks are performed on `memcpy`,
      \item whether calls such as strcpy are safe from buffer overflows under
        specific conditions, and
      \item whether malloc calls... % dominic?
    \end{enumerate}
  \item Results of testing the aforementioned plugins on the \texttt{GNU CoreUtils}
    software suite.
\end{enumerate}

\section{Approach}

\paragraph{}
Here we discuss our approach toward ensuring security properties as it evolved
over the course of the project. Initially, we determined to reason about each
of the cases in \S\ref{approachoverview} that relate to vulnerabilities
(2-4). 

\subsection{Unchecked Malloc and the Case for Reaching Definitions}

\paragraph{}
For example, consider the following code, where we desire to verify
that the return value of \texttt{malloc} is checked:

\begin{center}
\lstset{language=C, label=malloccheck,
caption=malloc.c, breaklines=true, basicstyle=\tiny, numbers=left}
\begin{lstlisting}
#include <stdlib.h>
#include <stdio.h>

int main() {
  // Uninitialized variable
  char *array = 0;


  array = malloc(32 * sizeof(*array));

  if (!array)
    return -1;

  free(array);

  return 0;
}
\end{lstlisting}
\end{center}

\paragraph{}
The disassembly of this binary might appear as follows (with two basic blocks,
before and after the call): 

\begin{center}
\lstset{language=C, label=mallocdisasm,
caption=Malloc disassembly, breaklines=true, basicstyle=\tiny, numbers=none}
\begin{lstlisting}
  begin(main\_ENTRY) 
      000082c8: 04 e0 2d e5    str lr, [sp, #-4]! 
      000082cc: 20 00 a0 e3    mov r0, #0x20       
      000082d0: 49 00 00 eb    bl #0x124           ; call malloc
  end(main\_ENTRY)
 
  begin(main\_0xc) 
      000082d4: 00 00 50 e3    cmp r0, #0x0        ; check malloc return value
      000082d8: 02 00 00 0a    beq #0x8            
  end(main\_0xc)
\end{lstlisting}
\end{center}

\paragraph{}
We would like to confirm that a check takes place after the call to malloc;
i.e., we would check for the presence of the \texttt{cmp} instruction and the
operand \texttt{r0} in \texttt{main\_0xc}.

\paragraph{}
However, it may easily be the case that the contents of \texttt{r0} are first
moved to another register, \texttt{r3}, which is subsequently checked by a
\texttt{cmp} instruction. In order to verify the buggy condition that the malloc
return value is never checked, we must verify that any flow of this data from
\texttt{r0} to other registers are also not checked. To obtain the statements
where \texttt{r0} data flows to, we make use of def-use chains. For the
definition of \texttt{r0} in the BIL IR, we check all uses of \texttt{r0} and
transitively look up the def-use chains for further registers, such as
\texttt{r3}, which the value in \texttt{r0} flows to. On the final set of
instructions, we verify that the data is subject to a \texttt{cmp} instruction.

\paragraph{}
This example demonstrates the need for def-use chains; our stack and heap based
analyses in turn also require use-def chains. Due to retreating edges in the
CFG, it is difficult to produce def-use chains given a single instruction. For
this reason we first implemented a dataflow framework and a
reaching-definitions pass. From the reaching definitions, we generate def-use
and use-def chains as necessary---e.g., we filter on those reaching definitions
which concern a particular use or def of a register.

\subsection{Data Flow Dependency}

An extension to the def-use and use-def chains was to produce the data (flow)
dependencies of a given statement in a forward or backward direction,
respectively. Essentially, given a register in a definition (such as a Move
instruction in the BIL IR), we can produce a set of all instructions that are
determined to transitively affect its value. We implement this
by way of a data dependency plugin for BAP. Consider the arguments to the
following \texttt{strcpy} call:

\begin{center}
\lstset{language=C, label=strcpy,
caption=strcpy.c, breaklines=true, basicstyle=\tiny, numbers=none}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv) {
  char dst[10] = {0};
  strcpy(dst, argv[1]);
}
\end{lstlisting}
\end{center}

For the \texttt{dst} variable on the stack, encoded as an
\texttt{<address,statement>} pair, we have:

\begin{verbatim}
    <(0x8490:32, 0)> R0 := R2 
\end{verbatim}

The plugin will determine all preceding instructions it is dependent on:
\begin{verbatim}
    <(0x8444:32, 3)> SP := SP - 0x8:32
    <(0x8448:32, 2)> R11 := SP + 0x4:32
    <(0x848C:32, 2)> R2 := R11 - 0x10:32
\end{verbatim}

Now, we can observe the role that the stack pointer \texttt{SP} plays
when considering \texttt{dst}. A full listing of the BIL disassembly,
as well as the data dependencies for \texttt{argv[1]} may be viewed in
the Appendix~\ref{appa}


\subsection{Unchecked Memory}

\subsection{Stack-based Security Outcomes}

% heap-based? or malloc?
\subsection{Malloc-based Security Outcomes}

\section{Experimental Setup}

\subsection{}


\section{Experimental Evaluation}



\section{Surprises and Lessons Learned}
\label{lessonslearned}



\section{Conclusions and Future Work}



\clearpage
\section{Related Work}


\appendix
\section{Appendix}
\label{appa}
\paragraph{BIL Dissasembly of Listing \ref{strcpy}}

\begin{verbatim}
  SP := SP - 0x8:32
  mem := mem         with [base_436 + 0xFFFFFFF8:32, el]:u32 <- R11
  mem := mem         with [base_436 + 0xFFFFFFFC:32, el]:u32 <- LR
  base_436 := SP
  R11 := SP + 0x4:32
  t_439 := 0x4:32
  s_438 := SP
  SP := SP - 0x18:32
  t_442 := 0x18:32
  s_441 := SP
  mem := mem         with [R11 + 0xFFFFFFE8:32, el]:u32 <- R0
  mem := mem         with [R11 + 0xFFFFFFE4:32, el]:u32 <- R1
  R3 := R11 - 0x10:32
  t_447 := 0x10:32
  s_446 := R11
  R2 := 0x0:32
  mem := mem         with [R3 + 0x0:32, el]:u32 <- R2
  R3 := R3 + 0x4:32
  t_452 := 0x4:32
  s_451 := R3
  R2 := 0x0:32
  mem := mem         with [R3 + 0x0:32, el]:u32 <- R2
  R3 := R3 + 0x4:32
  t_457 := 0x4:32
  s_456 := R3
  R2 := 0x0:32
  mem := mem         with [R3 + 0x0:32, el]:u16 <- t_460
  t_460 := low:16[R2]
  R3 := R3 + 0x2:32
  t_463 := 0x2:32
  s_462 := R3
  R3 := mem[R11 + 0xFFFFFFE4:32, el]:u32
  R3 := R3 + 0x4:32
  t_467 := 0x4:32
  s_466 := R3
  R3 := mem[R3 + 0x0:32, el]:u32
  R2 := R11 - 0x10:32
  t_471 := 0x10:32
  s_470 := R11
  R0 := R2
  R1 := R3
  jmp 0x82E0:32
  LR := 0x849C:32
\end{verbatim}

\paragraph{BIL data dependency instructions for \texttt{argv[1]}}

\begin{verbatim}
  <(0x8444:32, 0)> base_436 := SP
  <(0x8444:32, 1)> mem := mem         with [base_436 + 0xFFFFFFFC:32, el]:u32 <- LR
  <(0x8444:32, 2)> mem := mem         with [base_436 + 0xFFFFFFF8:32, el]:u32 <- R11
  <(0x8444:32, 3)> SP := SP - 0x8:32
  <(0x8448:32, 2)> R11 := SP + 0x4:32
  <(0x8450:32, 0)> mem := mem         with [R11 + 0xFFFFFFE8:32, el]:u32 <- R0
  <(0x8454:32, 0)> mem := mem         with [R11 + 0xFFFFFFE4:32, el]:u32 <- R1
  <(0x8458:32, 2)> R3 := R11 - 0x10:32
  <(0x845C:32, 0)> R2 := 0x0:32
  <(0x8460:32, 0)> mem := mem         with [R3 + 0x0:32, el]:u32 <- R2
  <(0x8464:32, 2)> R3 := R3 + 0x4:32
  <(0x8468:32, 0)> R2 := 0x0:32
  <(0x846C:32, 0)> mem := mem         with [R3 + 0x0:32, el]:u32 <- R2
  <(0x8470:32, 2)> R3 := R3 + 0x4:32
  <(0x8474:32, 0)> R2 := 0x0:32
  <(0x8478:32, 0)> t_460 := low:16[R2]
  <(0x8478:32, 1)> mem := mem         with [R3 + 0x0:32, el]:u16 <- t_460
  <(0x8480:32, 0)> R3 := mem[R11 + 0xFFFFFFE4:32, el]:u32
  <(0x8484:32, 2)> R3 := R3 + 0x4:32
  <(0x8488:32, 0)> R3 := mem[R3 + 0x0:32, el]:u32
\end{verbatim}

\nocite{*}
{\bibliographystyle{acm}
\bibliography{b1}}

\end{document}
